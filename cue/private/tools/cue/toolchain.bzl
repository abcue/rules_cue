# We must accommodate loading this file from repositories generated by
# our repository rules.
visibility("public")

_TOOLS_BY_RELEASE = {
    "v0.9.2": {
        struct(os = "darwin", arch = "amd64"): "87ebebb8459d579ff791843b3228ca64dc372181456d8e2b4ad4e3f0c607c94d",
        struct(os = "darwin", arch = "arm64"): "0f01909937c7f1b5b58d55e53a7d5366f3b4f8fc48dc31e391dd55340ea1ae95",
        struct(os = "linux", arch = "amd64"): "67c88f6c3bdf884301794c3ec91f9e6e3f660e7de3b7e10cd29fbbd291baac50",
        struct(os = "linux", arch = "arm64"): "3b90c49faaf3367338bd95db0bf76ec86bf4ca7d175d42a221e27bdc8d265256",
        struct(os = "windows", arch = "amd64"): "b63616df5dcc13dc968e714d4935d2823600aa5bdda049edbcaeb639c91a1c76",
        struct(os = "windows", arch = "arm64"): "30fb3b62889f45da8c79a75c4c8772ea47306e5edca5c921c7ffb9095522ae1c",
    },
    "v0.9.1": {
        struct(os = "darwin", arch = "amd64"): "5c64c0b098a3b42c47fa77893ef261a49fe779b894fd01b7747e665017332afd",
        struct(os = "darwin", arch = "arm64"): "b9d504dd947b4005ad52fba4fc4dcdab056d01bb59ad298278939283d2da2f4a",
        struct(os = "linux", arch = "amd64"): "3ece347a16db754d55d062ec8e8f9ee13ee97b647f49bd21efbb95468e30fe24",
        struct(os = "linux", arch = "arm64"): "68f4b42c3af26d0d159ed452a2f45537800213ac8552f54027333ceebc5bd7b1",
        struct(os = "windows", arch = "amd64"): "66d42dcc31c0098e2f5153dce83a130eda1aac156ec89d1053c493729e478f62",
        struct(os = "windows", arch = "arm64"): "a7366372d7f4280c01f6129d6c3c5f6de94bec6b26133d971e446dd15aa1263f",
    },
    "v0.9.0": {
        struct(os = "darwin", arch = "amd64"): "0b77cff3ec8f8184e7d9ec68174baec153905d61c417db6496a26217d8e1f1a9",
        struct(os = "darwin", arch = "arm64"): "736363199273e049ae223556ca63ebc8875b19f16bbf4f6c41bcea680df22fd4",
        struct(os = "linux", arch = "amd64"): "8ba567a8223c2cfc6850960adefbd600cc96f220d43e67653a98036be2b44228",
        struct(os = "linux", arch = "arm64"): "6f3b03b8046d29cdeb50a1313842afd2d8a352fdd68e80c5797f1fd88b85bde4",
        struct(os = "windows", arch = "amd64"): "f75354e2c40ed01d847eb83515f50561ea74927a05406387a261df2920033de0",
        struct(os = "windows", arch = "arm64"): "c3a5f81c67a37bc35d79b0c2bfefd566c25a7bf5417f54de3fbbd08705a89578",
    },
    "v0.8.2": {
        struct(os = "darwin", arch = "amd64"): "9f91ca27cfa7110c9e7b69ff751a6521be72db2b28e29b9b36b055e6ffb6d156",
        struct(os = "darwin", arch = "arm64"): "4c9244623ae0c95971dbcc5f938e210d96efd5c1850bb346b0bdaaf5190a375d",
        struct(os = "linux", arch = "amd64"): "9c95df381722b8e547ab6f257981c73246ac7c7f7a6da7571b405bef6ffb22a0",
        struct(os = "linux", arch = "arm64"): "af846c9c11925f4f28f051b8778c779535a307923d7d5fb2a9bdc92aa5925325",
        struct(os = "windows", arch = "amd64"): "7b172396a63b34c24612c6e9da0e49db137d35f35633b133d5a33eb82e4c3611",
        struct(os = "windows", arch = "arm64"): "7233a300e98cbdf542f6a4e111e60a090abe9e6d1cab595b47b480d4ace87ce7",
    },
    "v0.8.0": {
        struct(os = "darwin", arch = "amd64"): "d416cb4ea07a93094c71876c4757371e7f606095ee5861abdaa3cc71e4109ab7",
        struct(os = "darwin", arch = "arm64"): "1fac4b7df251b517f75969603f2bf47f683fe8072c2e4f54ef92559db80fc5ed",
        struct(os = "linux", arch = "amd64"): "e471126dc5e5e55a203066a4a4b1fb08d4cb027cf42517dfadc94c4e1b097767",
        struct(os = "linux", arch = "arm64"): "37027c826e6900a86d5d55803c64f1a28f063d5db600a807f6911f4d87213fe0",
        struct(os = "windows", arch = "amd64"): "8e3ced001982f10581dc1a6eeb82e08adee1b1e2abe5b7e837a35401895c6ba7",
        struct(os = "windows", arch = "arm64"): "f5e5d9d3c7d0649d16afdbc21bde51ebc558fe64ac51ae89085037363dd658fc",
    },
}

_DEFAULT_TOOL_VERSION = "v0.9.2"

def known_release_versions():
    return _TOOLS_BY_RELEASE.keys()

CUEInfo = provider(
    doc = "Details pertaining to the CUE toolchain.",
    fields = {
        "tool": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

CUEToolInfo = provider(
    doc = "Details pertaining to the CUE tool.",
    fields = {
        "binary": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

def _cue_tool_impl(ctx):
    return [CUEToolInfo(
        binary = ctx.executable.binary,
        version = ctx.attr.version,
    )]

cue_tool = rule(
    implementation = _cue_tool_impl,
    attrs = {
        "binary": attr.label(
            mandatory = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec",
            doc = "CUE tool to invoke",
        ),
        "version": attr.string(
            mandatory = True,
            doc = "This tool's released version name",
        ),
    },
)

def _toolchain_impl(ctx):
    tool = ctx.attr.tool[CUEToolInfo]
    toolchain_info = platform_common.ToolchainInfo(
        cueinfo = CUEInfo(
            tool = tool.binary,
            version = tool.version,
        ),
    )
    return [toolchain_info]

cue_toolchain = rule(
    implementation = _toolchain_impl,
    attrs = {
        "tool": attr.label(
            mandatory = True,
            providers = [CUEToolInfo],
            cfg = "exec",
            doc = "CUE tool to use for validating and exporting data.",
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_cue_toolchains(cue_tool):
    for version, platforms in _TOOLS_BY_RELEASE.items():
        for platform in platforms.keys():
            cue_toolchain(
                name = "{}_{}_{}".format(platform.os, platform.arch, version),
                tool = cue_tool,
            )

def _translate_host_platform(ctx):
    # NB: This is adapted from rules_go's "_detect_host_platform" function.
    os = ctx.os.name
    if os == "mac os x":
        os = "darwin"
    elif os.startswith("windows"):
        os = "windows"

    arch = ctx.os.arch
    if arch == "aarch64":
        arch = "arm64"
    elif arch == "x86_64":
        arch = "amd64"

    return os, arch

_MODULE_REPOSITORY_NAME = "rules_cue"
_CONTAINING_PACKAGE_PREFIX = "//cue/private/tools/cue"

def _download_tool_impl(ctx):
    if not ctx.attr.arch and not ctx.attr.os:
        os, arch = _translate_host_platform(ctx)
    else:
        if not ctx.attr.arch:
            fail('"os" is set but "arch" is not')
        if not ctx.attr.os:
            fail('"arch" is set but "os" is not')
        os, arch = ctx.attr.os, ctx.attr.arch
    version = ctx.attr.version

    sha256sum = _TOOLS_BY_RELEASE[version][struct(os = os, arch = arch)]
    if not sha256sum:
        fail('No CUE tool is available for OS "{}" and CPU architecture "{}" at version {}'.format(os, arch, version))
    ctx.report_progress('Downloading CUE tool for OS "{}" and CPU architecture "{}" at version {}.'.format(os, arch, version))
    ctx.download_and_extract(
        url = "https://github.com/cue-lang/cue/releases/download/{version}/cue_{version}_{os}_{arch}.{extension}".format(
            version = version,
            os = os,
            arch = arch,
            extension = "zip" if os == "windows" else "tar.gz",
        ),
        sha256 = sha256sum,
    )

    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.tool.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{extension}": ".exe" if os == "windows" else "",
            "{version}": version,
        },
    )
    return None

_download_tool = repository_rule(
    implementation = _download_tool_impl,
    attrs = {
        "arch": attr.string(),
        "os": attr.string(),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_bazel_toolchains(version, toolchain_prefix):
    native.constraint_value(
        name = version,
        constraint_setting = "{}:tool_version".format(_CONTAINING_PACKAGE_PREFIX),
    )
    constraint_value_prefix = "@{}//cue/private/tools".format(_MODULE_REPOSITORY_NAME)
    for platform in _TOOLS_BY_RELEASE[version].keys():
        native.toolchain(
            name = "{}_{}_{}_toolchain".format(platform.os, platform.arch, version),
            exec_compatible_with = [
                "{}:cpu_{}".format(constraint_value_prefix, platform.arch),
                "{}:os_{}".format(constraint_value_prefix, platform.os),
            ],
            toolchain = toolchain_prefix + (":{}_{}_{}".format(platform.os, platform.arch, version)),
            toolchain_type = "@{}//tools/cue:toolchain_type".format(_MODULE_REPOSITORY_NAME),
        )

def _toolchains_impl(ctx):
    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.toolchains.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{tool_repo}": ctx.attr.tool_repo,
            "{version}": ctx.attr.version,
        },
    )

_toolchains_repo = repository_rule(
    implementation = _toolchains_impl,
    attrs = {
        "tool_repo": attr.string(mandatory = True),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

def download_tool(name, version = None):
    _download_tool(
        name = name,
        version = version,
    )
    _toolchains_repo(
        name = name + "_toolchains",
        tool_repo = name,
        version = version,
    )
