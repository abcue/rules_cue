# We must accommodate loading this file from repositories generated by
# our repository rules.
visibility("public")

_TOOLS_BY_RELEASE = {
    "v0.15.4": {
        struct(os = "darwin", arch = "amd64"): "e64e6a9f30609ed619a203334a6404c46a9fb7685a86424f74c3c52a55ebfa1c",
        struct(os = "darwin", arch = "arm64"): "2d324ba027447a7dab2e980f3ccfb7e15a3dd9096258b9f69205153e4c5b46cd",
        struct(os = "linux", arch = "amd64"): "4709f0d3e9988b82192a205953fefdbb3637317a1cef63d84fe65b7b92ef95a3",
        struct(os = "linux", arch = "arm64"): "f5a47ef6a6566849543b0ea84a7058c690bbb1492a1c101a6d62feaf59f8112e",
        struct(os = "windows", arch = "amd64"): "d42e26a0fb09219fc1735326fb2188dadf7c8deab136698a55d793c0c15a6aaa",
        struct(os = "windows", arch = "arm64"): "a19ce1f517879b1bb3f5cb815364a2ec74b0302b54a86f5802a2c56ae3b7ba97",
    },
    "v0.15.3": {
        struct(os = "darwin", arch = "amd64"): "44f177363bb59453371d9bf3dd2097c6bd7fc0fccb2eaf2cfde8bc934c8ba174",
        struct(os = "darwin", arch = "arm64"): "9b84bbd0ef1050b51328e4d9af47b2e88c772765d5c74594277417a4bc083a68",
        struct(os = "linux", arch = "amd64"): "309bbe62ebb0e74a2b298d2808edb0eadfd19789ed0de259b61721f19e3b5ff0",
        struct(os = "linux", arch = "arm64"): "db9e6b15d02f838c47b65e4c5184caf8456e389be28a274f5186e19fab335015",
        struct(os = "windows", arch = "amd64"): "d291bd510887bf1308a6bc07c28d17c7f01bc75e7a885adacdbd30d6d6ecbd20",
        struct(os = "windows", arch = "arm64"): "f7b72102bcf227800276bfb22d0d16cfcdaeceb79a1e99af492aaa3eea6bb839",
    },
    "v0.15.1": {
        struct(os = "darwin", arch = "amd64"): "e761c85f060283d7c52b0b80e3ae57b569a0c4e7f7029bdbf38d7f079b2128bc",
        struct(os = "darwin", arch = "arm64"): "9ee183ec8686675a0aea24f9f5cfb64235ee4e7583e8e771432a0bf58e64411a",
        struct(os = "linux", arch = "amd64"): "aa282261245e9ab0d65b17ec3c7207f5231600106f7b26fc0c2e158b3937ca3f",
        struct(os = "linux", arch = "arm64"): "6bb80ec3262c7cedf898a21e9e9481c86da54488f144788b1fa0a5dc01879a0b",
        struct(os = "windows", arch = "amd64"): "516fa080c1af12578ff76a4165cc7bf14ad9bbe5d9724a0c07553860d038885e",
        struct(os = "windows", arch = "arm64"): "bf789490a4c9b1fe2aec8b1b078fb5cdd428c4653fae1a0572cb75c1ade50ca7",
    },
    "v0.15.0": {
        struct(os = "darwin", arch = "amd64"): "3674a0d19cf9bdd5c2ef68ca5e5adf7b2c2782956fd3fc08643ef59ae15a8a5d",
        struct(os = "darwin", arch = "arm64"): "7fcdfd1774ead0b6d44971e2e157d2a2e3bf22e4d1dd6efb010e7a09cae88d1f",
        struct(os = "linux", arch = "amd64"): "06925fc1e5174591cef0b1e42ac32cff4271804742cd20893de1793b6d82d460",
        struct(os = "linux", arch = "arm64"): "8cd82e968dc0168cf9ea2efdb0f3ce4a3d97b7afd59c8d55cc40adb0a9aa7224",
        struct(os = "windows", arch = "amd64"): "188931801ff39cd397589a7a271ede54ef0694900ca3f06bc9834dddbb3f39ae",
        struct(os = "windows", arch = "arm64"): "a47d356e4ad3cd891df55c28c24763193f4973662be9ccc4704090083d89ff34",
    },
    "v0.14.2": {
        struct(os = "darwin", arch = "amd64"): "0cd05e9753774d6590448ea52d58ad5e9701ab04fa95b1cd8fefce67c2d763e8",
        struct(os = "darwin", arch = "arm64"): "71c3d5175dfa9caa48de3f86fdb128f8137f0c391a44221ae0e6b32bd2d894d5",
        struct(os = "linux", arch = "amd64"): "de6bcd5a601ca53dde09de8e5f884a4bad23c91306f04ca6a6ce11dab48a8307",
        struct(os = "linux", arch = "arm64"): "8066e452c6788d980422d5f6328a03cc6d55bf5033647f1ee48c092290a67830",
        struct(os = "windows", arch = "amd64"): "0a1c6a050494d2d8d671e15967d2d2ab2bd37dce48e193e59728242797c86bb0",
        struct(os = "windows", arch = "arm64"): "2187a7909951bff30dd621dde368cdeebc30dc5fcf8d93f2f9c3ddc558aeca1d",
    },
    "v0.14.1": {
        struct(os = "darwin", arch = "amd64"): "61e4931a122c9a706429b76bd7275505a0b75edeb078e0bf2d6352d6b9f7b02b",
        struct(os = "darwin", arch = "arm64"): "54e7d5e694c85dbae40fa8e1b73894950fd8854e4fe64b57550aa8ff19bfcbf6",
        struct(os = "linux", arch = "amd64"): "c7d29f5988d088627cf53bd6a223807c466066cf432c7cf5c36429ffc9e734f6",
        struct(os = "linux", arch = "arm64"): "486dcd03b27553bca4f0289fe2cb9e1f2c3c025bd053675c72b0c13577364b46",
        struct(os = "windows", arch = "amd64"): "b2289feb775db9d10de6c039ffeccc8afb7a7fe0c656af891f8fce7f38aa1d8a",
        struct(os = "windows", arch = "arm64"): "3ba4b950b1880aec6f3ddd5d96f43648e4e0ff58151ffc17375068ef9ebf361a",
    },
    "v0.14.0": {
        struct(os = "darwin", arch = "amd64"): "bcbe7d6c2139f6b116945112c17687a25cf60a36deef4f3d5af873bc7e4260bf",
        struct(os = "darwin", arch = "arm64"): "9f1a88e2ccabe12f24bbd3934ab8a487ccfa78df2aae1183b9b39c26bded9a7a",
        struct(os = "linux", arch = "amd64"): "5733fe3a138eaacf8f8298f22c568e3ad55b3141971c1be9151906217fc2ee6a",
        struct(os = "linux", arch = "arm64"): "f987b1f8cba359973a3050ac276d01e29162cda1de6a4ddb135ff6186bfa6f02",
        struct(os = "windows", arch = "amd64"): "9041f014820924e4fde7bb2c295f4da63e9ad6590f92d73e6c4bc37abe5f2077",
        struct(os = "windows", arch = "arm64"): "045878cf337143b54ccaff2718c4dd2431922ad53182a17d088e7a3d731b032b",
    },
}

_DEFAULT_TOOL_VERSION = "v0.15.4"

def known_release_versions():
    return _TOOLS_BY_RELEASE.keys()

CUEInfo = provider(
    doc = "Details pertaining to the CUE toolchain.",
    fields = {
        "tool": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

CUEToolInfo = provider(
    doc = "Details pertaining to the CUE tool.",
    fields = {
        "binary": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

def _cue_tool_impl(ctx):
    return [CUEToolInfo(
        binary = ctx.executable.binary,
        version = ctx.attr.version,
    )]

cue_tool = rule(
    implementation = _cue_tool_impl,
    attrs = {
        "binary": attr.label(
            mandatory = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec",
            doc = "CUE tool to invoke",
        ),
        "version": attr.string(
            mandatory = True,
            doc = "This tool's released version name",
        ),
    },
)

def _toolchain_impl(ctx):
    tool = ctx.attr.tool[CUEToolInfo]
    toolchain_info = platform_common.ToolchainInfo(
        cueinfo = CUEInfo(
            tool = tool.binary,
            version = tool.version,
        ),
    )
    return [toolchain_info]

cue_toolchain = rule(
    implementation = _toolchain_impl,
    attrs = {
        "tool": attr.label(
            mandatory = True,
            providers = [CUEToolInfo],
            cfg = "exec",
            doc = "CUE tool to use for validating and exporting data.",
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_cue_toolchains(cue_tool):
    for version, platforms in _TOOLS_BY_RELEASE.items():
        for platform in platforms.keys():
            cue_toolchain(
                name = "{}_{}_{}".format(platform.os, platform.arch, version),
                tool = cue_tool,
            )

def _translate_host_platform(ctx):
    # NB: This is adapted from rules_go's "_detect_host_platform" function.
    os = ctx.os.name
    if os == "mac os x":
        os = "darwin"
    elif os.startswith("windows"):
        os = "windows"

    arch = ctx.os.arch
    if arch == "aarch64":
        arch = "arm64"
    elif arch == "x86_64":
        arch = "amd64"

    return os, arch

_MODULE_REPOSITORY_NAME = "rules_cue"
_CONTAINING_PACKAGE_PREFIX = "//cue/private/tools/cue"

def _download_tool_impl(ctx):
    if not ctx.attr.arch and not ctx.attr.os:
        os, arch = _translate_host_platform(ctx)
    else:
        if not ctx.attr.arch:
            fail('"os" is set but "arch" is not')
        if not ctx.attr.os:
            fail('"arch" is set but "os" is not')
        os, arch = ctx.attr.os, ctx.attr.arch
    version = ctx.attr.version

    sha256sum = _TOOLS_BY_RELEASE[version][struct(os = os, arch = arch)]
    if not sha256sum:
        fail('No CUE tool is available for OS "{}" and CPU architecture "{}" at version {}'.format(os, arch, version))
    ctx.report_progress('Downloading CUE tool for OS "{}" and CPU architecture "{}" at version {}.'.format(os, arch, version))
    ctx.download_and_extract(
        url = "https://github.com/cue-lang/cue/releases/download/{version}/cue_{version}_{os}_{arch}.{extension}".format(
            version = version,
            os = os,
            arch = arch,
            extension = "zip" if os == "windows" else "tar.gz",
        ),
        sha256 = sha256sum,
    )

    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.tool.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{extension}": ".exe" if os == "windows" else "",
            "{version}": version,
        },
    )
    return None

_download_tool = repository_rule(
    implementation = _download_tool_impl,
    attrs = {
        "arch": attr.string(),
        "os": attr.string(),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_bazel_toolchains(version, toolchain_prefix):
    native.constraint_value(
        name = version,
        constraint_setting = "{}:tool_version".format(_CONTAINING_PACKAGE_PREFIX),
    )
    constraint_value_prefix = "@{}//cue/private/tools".format(_MODULE_REPOSITORY_NAME)
    for platform in _TOOLS_BY_RELEASE[version].keys():
        native.toolchain(
            name = "{}_{}_{}_toolchain".format(platform.os, platform.arch, version),
            exec_compatible_with = [
                "{}:cpu_{}".format(constraint_value_prefix, platform.arch),
                "{}:os_{}".format(constraint_value_prefix, platform.os),
            ],
            toolchain = toolchain_prefix + (":{}_{}_{}".format(platform.os, platform.arch, version)),
            toolchain_type = "@{}//tools/cue:toolchain_type".format(_MODULE_REPOSITORY_NAME),
        )

def _toolchains_impl(ctx):
    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.toolchains.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{tool_repo}": ctx.attr.tool_repo,
            "{version}": ctx.attr.version,
        },
    )

_toolchains_repo = repository_rule(
    implementation = _toolchains_impl,
    attrs = {
        "tool_repo": attr.string(mandatory = True),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

def download_tool(name, version = None):
    _download_tool(
        name = name,
        version = version,
    )
    _toolchains_repo(
        name = name + "_toolchains",
        tool_repo = name,
        version = version,
    )
