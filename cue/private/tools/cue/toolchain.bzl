# We must accommodate loading this file from repositories generated by
# our repository rules.
visibility("public")

_TOOLS_BY_RELEASE = {
    "v0.6.0-alpha.2": {
        struct(os = "darwin", arch = "amd64"): "88e5045aa3ee452cf8dea387bc5b43a0353cdde35b76d1ddf61ef4a90b634af7",
        struct(os = "darwin", arch = "arm64"): "66abd69dc31224996e10a5c216bec44ffa346e72973a0b19307ce8665a022b2b",
        struct(os = "linux", arch = "amd64"): "ecae7e33622a13b0925186711caa4f8aae23d445d02cde37b894775b5ed91035",
        struct(os = "linux", arch = "arm64"): "c438a43c420cb31c076ff8fa539a4184825c133dba9fe92e2d9a2c896edce31e",
        struct(os = "windows", arch = "amd64"): "6f31984f89c9508bc28b00b103c007cd6ee3eeb34ee775d8b81df2e7c397cd5b",
        struct(os = "windows", arch = "arm64"): "12e07f14d7cc1b70e2cf0ac72f9876d45eb9cd2b03242a17c459bca23d4753d6",
    },
    "v0.6.0-alpha.1": {
        struct(os = "darwin", arch = "amd64"): "39846589363fd642d082561906894934d06fc6bde2fed9eef8f7ed9aec463a9f",
        struct(os = "darwin", arch = "arm64"): "bdc5a9b9feb3e310bd1261eb472a3b77df76a060dd65712409d716835afa3e1b",
        struct(os = "linux", arch = "amd64"): "2e3a75fc1a43622d851a389d66f505f8c30a43af9ec83181afadad168795acd8",
        struct(os = "linux", arch = "arm64"): "2fb8807aa8d9ac5d1c8af3137f619e7fa769969cd3801dcb39f65b3c6672af5b",
        struct(os = "windows", arch = "amd64"): "670ad986473ce076d1837ce068bea9aae01994dc986433f89d393a476b7e428f",
        struct(os = "windows", arch = "arm64"): "73488be820c92ec48ca765dbcc1daf72fff9d60341edca3235a266ff2ed2ad8f",
    },
    "v0.5.0": {
        struct(os = "darwin", arch = "amd64"): "e2cede1965afa66dc52de7c1cd461227f4ff924f7a2adc9791cf1a699485409f",
        struct(os = "darwin", arch = "arm64"): "00fc991977232240893ae36dc852366af859214d6e1b2b9e03e93b8f9f0991a7",
        struct(os = "linux", arch = "amd64"): "38c9a2f484076aeafd9f522efdee40538c31337539bd8c80a29f5c4077314e53",
        struct(os = "linux", arch = "arm64"): "735fa1b9bb02ef0ee79dd40c418760687776b44747f43f2e26c3bca4e1fd96f6",
        struct(os = "windows", arch = "amd64"): "0aec9ea6b4095250406f8072d959bbea4c29bdcf9f85579f2c6dc915ce75082e",
        struct(os = "windows", arch = "arm64"): "262f381041d6ebdf6a8b87fe482077efd9212e7d195a81fe437a2c24afe4d871",
    },
    "v0.5.0-beta.5": {
        struct(os = "darwin", arch = "amd64"): "a42fb422c7fd8ea0b8b1bb8289107a418da6ddaf0e37fd6aca1dc7d6fd7b583c",
        struct(os = "darwin", arch = "arm64"): "6fb64fdf2338622e5a3bf46b7abc08611386faf3b6807e5cb2543dffa73c2609",
        struct(os = "linux", arch = "amd64"): "f2f4590ff33c9d5730973c97c2d75a17f2447bae8b547915a60f55e61c5ae298",
        struct(os = "linux", arch = "arm64"): "0f2df97ba7aa6e4bbb361cf5e70b17f210efe321f1be54791d272f18e0761a6d",
        struct(os = "windows", arch = "amd64"): "8e927f05f1fb82215b7fbdc03cb9a19bc882603ea30ba0f57e30865c654269da",
        struct(os = "windows", arch = "arm64"): "9066faea531bbeff3e63d165614a1b17f2ce988df5011a2eeb6ccb09f91d67aa",
    },
    "v0.5.0-beta.2": {
        struct(os = "darwin", arch = "amd64"): "3e09097396c513795fcfe58adeb648cc860091ce72a14404b5c5594c1e4b063f",
        struct(os = "darwin", arch = "arm64"): "d0f0e27f4086e283de52acf3367c3a3671843f3dae9b1fc42d54c5311d529fc0",
        struct(os = "linux", arch = "amd64"): "2442309d506008061414f13625633370b904cd0b2a4e4b157f33d3b773584640",
        struct(os = "linux", arch = "arm64"): "de7d476a3775aa860a991edf1a7cef4cb223b28e15145ec62afb00c0ee569c1c",
        struct(os = "windows", arch = "amd64"): "7aa4fad5cdc97c78dacc5ee294c6f5faaf057d870b495ef91fb0e3b80c529931",
        struct(os = "windows", arch = "arm64"): "716a0a6bbf4e086a2defc9ecbe2d95f1f7f01888265e9cc5763b50043d827245",
    },
    "v0.5.0-beta.1": {
        struct(os = "darwin", arch = "amd64"): "936dedc7f1630821956bae5d8aab7b0f0c5c63ea56d329c5030b59fb2613b0cd",
        struct(os = "darwin", arch = "arm64"): "9fa583fcdd45e4f446388aca1f50acc213c2186fe0491e21448051eed0d2b2a2",
        struct(os = "linux", arch = "amd64"): "8fba35aa3aaa9ab7ec012f6522d006125168605c24fe93e14f6aec5789f99df0",
        struct(os = "linux", arch = "arm64"): "4d9c36b4b491ba4a4bf851eda384402bd98e4ba0b54aeccedc51067644a43848",
        struct(os = "windows", arch = "amd64"): "015dac67700ebed36babb9b72d1823a7590bbfabf929dd7df308b44c3ed532c1",
        struct(os = "windows", arch = "arm64"): "6002984bfec5362572eaf7995b19bf55c0085f6e9171614e2f4b8ad3c84dfc6e",
    },
    "v0.4.3": {
        struct(os = "darwin", arch = "amd64"): "1161254cf38b928b87a7ac1552dc2e12e6c5da298f9ce370d80e5518ddb6513d",
        struct(os = "darwin", arch = "arm64"): "3d84b85a7288f94301a4726dcf95b2d92c8ff796c4d45c4733fbdcc04ceaf21d",
        struct(os = "linux", arch = "amd64"): "5e7ecb614b5926acfc36eb1258800391ab7c6e6e026fa7cacbfe92006bac895c",
        struct(os = "linux", arch = "arm64"): "a8c3f4140d18c324cc69f5de4df0566e529e1636cff340095a42475799bf3fed",
        struct(os = "windows", arch = "amd64"): "67f76e36809565c1396cea1b44978d98807d980d55a7ddc3979396d34fac1037",
        struct(os = "windows", arch = "arm64"): "a87573f32213a72d763dd624a1b63414e3d862ae4cef0b2698652aef380ebe60",
    },
}

_DEFAULT_TOOL_VERSION = "v0.5.0"

def known_release_versions():
    return _TOOLS_BY_RELEASE.keys()

CUEInfo = provider(
    doc = "Details pertaining to the CUE toolchain.",
    fields = {
        "tool": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

CUEToolInfo = provider(
    doc = "Details pertaining to the CUE tool.",
    fields = {
        "binary": "CUE tool to invoke",
        "version": "This tool's released version name",
    },
)

def _cue_tool_impl(ctx):
    return [CUEToolInfo(
        binary = ctx.executable.binary,
        version = ctx.attr.version,
    )]

cue_tool = rule(
    implementation = _cue_tool_impl,
    attrs = {
        "binary": attr.label(
            mandatory = True,
            allow_single_file = True,
            executable = True,
            cfg = "exec",
            doc = "CUE tool to invoke",
        ),
        "version": attr.string(
            mandatory = True,
            doc = "This tool's released version name",
        ),
    },
)

def _toolchain_impl(ctx):
    tool = ctx.attr.tool[CUEToolInfo]
    toolchain_info = platform_common.ToolchainInfo(
        cueinfo = CUEInfo(
            tool = tool.binary,
            version = tool.version,
        ),
    )
    return [toolchain_info]

cue_toolchain = rule(
    implementation = _toolchain_impl,
    attrs = {
        "tool": attr.label(
            mandatory = True,
            providers = [CUEToolInfo],
            cfg = "exec",
            doc = "CUE tool to use for validating and exporting data.",
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_cue_toolchains(cue_tool):
    for version, platforms in _TOOLS_BY_RELEASE.items():
        for platform in platforms.keys():
            cue_toolchain(
                name = "{}_{}_{}".format(platform.os, platform.arch, version),
                tool = cue_tool,
            )

def _translate_host_platform(ctx):
    # NB: This is adapted from rules_go's "_detect_host_platform" function.
    os = ctx.os.name
    if os == "mac os x":
        os = "darwin"
    elif os.startswith("windows"):
        os = "windows"

    arch = ctx.os.arch
    if arch == "aarch64":
        arch = "arm64"
    elif arch == "x86_64":
        arch = "amd64"

    return os, arch

_MODULE_REPOSITORY_NAME = "rules_cue"
_CONTAINING_PACKAGE_PREFIX = "//cue/private/tools/cue"

def _download_tool_impl(ctx):
    if not ctx.attr.arch and not ctx.attr.os:
        os, arch = _translate_host_platform(ctx)
    else:
        if not ctx.attr.arch:
            fail('"os" is set but "arch" is not')
        if not ctx.attr.os:
            fail('"arch" is set but "os" is not')
        os, arch = ctx.attr.os, ctx.attr.arch
    version = ctx.attr.version

    sha256sum = _TOOLS_BY_RELEASE[version][struct(os = os, arch = arch)]
    if not sha256sum:
        fail('No CUE tool is available for OS "{}" and CPU architecture "{}" at version {}'.format(os, arch, version))
    ctx.report_progress('Downloading CUE tool for OS "{}" and CPU architecture "{}" at version {}.'.format(os, arch, version))
    ctx.download_and_extract(
        url = "https://github.com/cue-lang/cue/releases/download/{version}/cue_{version}_{os}_{arch}.{extension}".format(
            version = version,
            os = os,
            arch = arch,
            extension = "zip" if os == "windows" else "tar.gz",
        ),
        sha256 = sha256sum,
    )

    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.tool.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{extension}": ".exe" if os == "windows" else "",
            "{version}": version,
        },
    )
    return None

_download_tool = repository_rule(
    implementation = _download_tool_impl,
    attrs = {
        "arch": attr.string(),
        "os": attr.string(),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

# buildifier: disable=unnamed-macro
def declare_bazel_toolchains(version, toolchain_prefix):
    native.constraint_value(
        name = version,
        constraint_setting = "{}:tool_version".format(_CONTAINING_PACKAGE_PREFIX),
    )
    constraint_value_prefix = "@{}//cue/private/tools".format(_MODULE_REPOSITORY_NAME)
    for platform in _TOOLS_BY_RELEASE[version].keys():
        native.toolchain(
            name = "{}_{}_{}_toolchain".format(platform.os, platform.arch, version),
            exec_compatible_with = [
                "{}:cpu_{}".format(constraint_value_prefix, platform.arch),
                "{}:os_{}".format(constraint_value_prefix, platform.os),
            ],
            toolchain = toolchain_prefix + (":{}_{}_{}".format(platform.os, platform.arch, version)),
            toolchain_type = "@{}//tools/cue:toolchain_type".format(_MODULE_REPOSITORY_NAME),
        )

def _toolchains_impl(ctx):
    ctx.template(
        "BUILD.bazel",
        Label("{}:BUILD.toolchains.bazel".format(_CONTAINING_PACKAGE_PREFIX)),
        executable = False,
        substitutions = {
            "{containing_package_prefix}": "@{}{}".format(_MODULE_REPOSITORY_NAME, _CONTAINING_PACKAGE_PREFIX),
            "{tool_repo}": ctx.attr.tool_repo,
            "{version}": ctx.attr.version,
        },
    )

_toolchains_repo = repository_rule(
    implementation = _toolchains_impl,
    attrs = {
        "tool_repo": attr.string(mandatory = True),
        "version": attr.string(
            values = _TOOLS_BY_RELEASE.keys(),
            default = _DEFAULT_TOOL_VERSION,
        ),
    },
)

def download_tool(name, version = None):
    _download_tool(
        name = name,
        version = version,
    )
    _toolchains_repo(
        name = name + "_toolchains",
        tool_repo = name,
        version = version,
    )
